--- folder_comparator_v26.00.py Part 06/12
def _scan_folder(root_path, comparison_results_dict, is_source_scan_flag, ignore_case):
    # This function now directly populates comparison_results_dict for all categories

    current_scan_folder_basename = os.path.basename(root_path)

    scanned_non_excluded_items = {}
    print(f"{'Scanning folder':<25} : {root_path} ...")

    for dirpath, dirnames, filenames in os.walk(root_path, followlinks=False):
        # Determine relative path of current directory for exclusion checks
        current_relative_dir = os.path.relpath(dirpath, root_path)
        if current_relative_dir == ".": # Root directory itself
            current_relative_dir = "" 

        # Process directories first (dirnames is mutable, can be modified to prune walk)
        dirnames_to_process = list(dirnames) # Iterate over a copy
        for dirname in dirnames_to_process:
            full_path = os.path.join(dirpath, dirname)
            relative_path = os.path.join(current_relative_dir, dirname)
            relative_path_with_sep = relative_path + os.sep # For directory patterns and reporting
            is_excluded_flag = False
            matched_pattern = None # Initialize matched_pattern

            # --- Check for broken symlinks ---
            is_current_symlink = os.path.islink(full_path)
            if is_current_symlink:
                try:
                    # Does the symlink's target exist?
                    if not os.path.exists(os.path.realpath(full_path)):
                        # It's a broken symlink. Add it and remove from further processing.
                        if is_source_scan_flag:
                            comp_item_broken = ComparisonItem(relative_path_with_sep)
                            comp_item_broken.is_dir_source = True
                            comp_item_broken.is_symlink_source = True
                            comp_item_broken.is_broken_symlink_source = True
                            comparison_results_dict[REPORT_BROKEN_SYMLINK_SOURCE].append(comp_item_broken)
                        else:
                            comp_item_broken = ComparisonItem(relative_path_with_sep)
                            comp_item_broken.is_dir_target = True
                            comp_item_broken.is_symlink_target = True
                            comp_item_broken.is_broken_symlink_target = True
                            comparison_results_dict[REPORT_BROKEN_SYMLINK_TARGET].append(comp_item_broken)
                        if DEBUG_EXCLUDE_ENABLED:
                            print(f"DEBUG: Broken symlink (dir) detected in {current_scan_folder_basename}: {relative_path_with_sep}")
                        dirnames.remove(dirname) # Prune this directory from further walk if it's a symlink
                        continue # Skip further processing for this broken symlink
                except OSError as e:
                    # Error accessing the symlink itself or its target path during realpath check.
                    # Treat as a broken symlink (as we can't verify its target due to error) and also log as error for visibility.
                    if is_source_scan_flag:
                        comp_item_broken = ComparisonItem(relative_path_with_sep)
                        comp_item_broken.is_dir_source = True
                        comp_item_broken.is_symlink_source = True
                        comp_item_broken.is_broken_symlink_source = True
                        comp_item_broken.comparison_error_message = f"realpath error: {e}"
                        comparison_results_dict[REPORT_BROKEN_SYMLINK_SOURCE].append(comp_item_broken)
                    else:
                        comp_item_broken = ComparisonItem(relative_path_with_sep)
                        comp_item_broken.is_dir_target = True
                        comp_item_broken.is_symlink_target = True
                        comp_item_broken.is_broken_symlink_target = True
                        comp_item_broken.comparison_error_message = f"realpath error: {e}"
                        comparison_results_dict[REPORT_BROKEN_SYMLINK_TARGET].append(comp_item_broken)
                    if DEBUG_EXCLUDE_ENABLED:
                        print(f"DEBUG: Broken symlink (dir, realpath error) detected in {current_scan_folder_basename}: {relative_path_with_sep} (realpath error: {e})")
                    dirnames.remove(dirname) # Prune this directory from further walk
                    continue

            # --- Check for exclusion ---
            if is_excluded_flag:
                if DEBUG_EXCLUDE_ENABLED:
                    print(f"DEBUG EXCLUDE (DIR): {current_scan_folder_basename} - '{relative_path_with_sep}' matched by '{matched_pattern}'")
                # Get stat info for mtime, even for excluded directories
                try:
                    dir_stat = os.lstat(full_path) if is_current_symlink else os.stat(full_path)
                    mtime_ns = dir_stat.st_mtime_ns
                except OSError:
                    mtime_ns = None # Cannot get mtime, set to None
                comp_item_excluded = ComparisonItem(relative_path_with_sep)
                if is_source_scan_flag:
                    comp_item_excluded.is_dir_source = True
                    comp_item_excluded.is_excluded_source = True
                    comp_item_excluded.exclusion_matched_pattern_source = matched_pattern
                    comp_item_excluded.mtime_ns_source = mtime_ns
                    # Check if directory is empty for size_source
                    try: # Add try-except for os.listdir in case of permission error
                        if not os.listdir(full_path):
                            comp_item_excluded.size_source = 0
                    except OSError:
                        pass # Directory content cannot be listed, assume non-empty or handle as error elsewhere
                else:
                    comp_item_excluded.is_dir_target = True
                    comp_item_excluded.is_excluded_target = True
                    comp_item_excluded.exclusion_matched_pattern_target = matched_pattern
                    comp_item_excluded.mtime_ns_target = mtime_ns
                    try:
                        if not os.listdir(full_path):
                            comp_item_excluded.size_target = 0
                    except OSError:
                        pass
                comparison_results_dict[REPORT_EXCLUDED].append(comp_item_excluded)
                dirnames.remove(dirname) # Prune this directory from further walk
                continue # Skip further processing for this excluded directory

            # Directories don't have size or mtime for comparison purposes
            try:
                dir_stat = os.lstat(full_path) if is_current_symlink else os.stat(full_path)
                key_path = relative_path.lower() if ignore_case else relative_path
                scanned_non_excluded_items[key_path] = ScannedItem(
                    full_path=full_path,
                    is_dir=True,
                    size=None, # Size for directories is still None as it's not directly comparable
                    mtime_ns=dir_stat.st_mtime_ns, # Capture mtime_ns for directories
                    is_symlink=is_current_symlink,
                    symlink_target=os.path.realpath(full_path) if is_current_symlink else None
                )
            except OSError as e:
                # Log an error if we can't stat the directory, but still allow scan to continue
                comparison_results_dict[REPORT_COMPARE_ERROR].append(f"{relative_path_with_sep} (directory scanning error: {e})")
                continue # Skip this directory if we can't get its stats

        # Process files
        for filename in filenames:
            full_path = os.path.join(dirpath, filename)
            relative_path = os.path.join(current_relative_dir, filename)

            is_excluded_flag = False
            matched_pattern = None # Initialize matched_pattern

            # --- Check for broken symlinks ---
            is_current_symlink = os.path.islink(full_path)
            if is_current_symlink:
                try:
                    if not os.path.exists(os.path.realpath(full_path)):
                        # Initialize comp_item_broken here, unconditionally
                        comp_item_broken = ComparisonItem(relative_path)
                        if is_source_scan_flag:
                            comp_item_broken.is_dir_source = False
                            comp_item_broken.is_symlink_source = True
                            comp_item_broken.is_broken_symlink_source = True
                            comparison_results_dict[REPORT_BROKEN_SYMLINK_SOURCE].append(comp_item_broken)
                        else:
                            comp_item_broken.is_dir_target = False
                            comp_item_broken.is_symlink_target = True
                            comp_item_broken.is_broken_symlink_target = True
                            comparison_results_dict[REPORT_BROKEN_SYMLINK_TARGET].append(comp_item_broken)
                        if DEBUG_EXCLUDE_ENABLED:
                            print(f"DEBUG: Broken symlink (file) detected in {current_scan_folder_basename}: {relative_path}")
                        continue # Skip further processing
                except OSError as e:
                    if is_source_scan_flag:
                        comp_item_broken_error = ComparisonItem(relative_path)
                        comp_item_broken_error.is_dir_source = False
                        comp_item_broken_error.is_symlink_source = True
                        comp_item_broken_error.is_broken_symlink_source = True
                        comp_item_broken_error.comparison_error_message = f"realpath error: {e}"
                        comparison_results_dict[REPORT_BROKEN_SYMLINK_SOURCE].append(comp_item_broken_error)
                    else:
                        comp_item_broken_error = ComparisonItem(relative_path)
                        comp_item_broken_error.is_dir_target = False
                        comp_item_broken_error.is_symlink_target = True
                        comp_item_broken_error.is_broken_symlink_target = True
                        comp_item_broken_error.comparison_error_message = f"realpath error: {e}"
                        comparison_results_dict[REPORT_BROKEN_SYMLINK_TARGET].append(comp_item_broken_error)
                    if DEBUG_EXCLUDE_ENABLED:
                        print(f"DEBUG: Broken symlink (file, realpath error) detected in {current_scan_folder_basename}: {relative_path} (realpath error: {e})")
                    continue

            # --- Check for exclusion ---
            is_excluded_flag, matched_pattern = is_excluded(relative_path, False, current_scan_folder_basename) # Re-assign if excluded
            if is_excluded_flag:
                if DEBUG_EXCLUDE_ENABLED:
                    print(f"DEBUG EXCLUDE (FILE): {current_scan_folder_basename} - '{relative_path}' matched by '{matched_pattern}'")
                # Get stat info for excluded files
                try:
                    file_stat = os.lstat(full_path) if is_current_symlink else os.stat(full_path)
                    size = file_stat.st_size
                    mtime_ns = file_stat.st_mtime_ns
                except OSError:
                    size = None
                    mtime_ns = None # Cannot get size/mtime, set to None
                comp_item_excluded = ComparisonItem(relative_path)
                if is_source_scan_flag:
                    comp_item_excluded.is_dir_source = False
                    comp_item_excluded.is_excluded_source = True
                    comp_item_excluded.exclusion_matched_pattern_source = matched_pattern
                    comp_item_excluded.size_source = size
                    comp_item_excluded.mtime_ns_source = mtime_ns
                else:
                    comp_item_excluded.is_dir_target = False
                    comp_item_excluded.is_excluded_target = True
                    comp_item_excluded.exclusion_matched_pattern_target = matched_pattern
                    comp_item_excluded.size_target = size
                    comp_item_excluded.mtime_ns_target = mtime_ns
                comparison_results_dict[REPORT_EXCLUDED].append(comp_item_excluded)
                continue # Skip further processing

            # If not excluded and not a broken symlink, add to scanned items
            try:
                # For symlinks, use os.lstat to get information about the link itself.
                # For regular files, use os.stat.
                file_stat = os.lstat(full_path) if is_current_symlink else os.stat(full_path)

                key_path = relative_path.lower() if ignore_case else relative_path
                scanned_non_excluded_items[key_path] = ScannedItem(
                    full_path=full_path,
                    is_dir=False,
                    size=file_stat.st_size,
                    mtime_ns=file_stat.st_mtime_ns,
                    is_symlink=is_current_symlink,
                    symlink_target=os.path.realpath(full_path) if is_current_symlink else None
                )
            except OSError as e:
                # This is a file that is not a broken symlink or excluded, but we can't stat it.
                # This is a valid comparison error.
                comp_item_error = ComparisonItem(relative_path)
                comp_item_error.is_dir_source = False # It's a file
                comp_item_error.is_dir_target = False
                comp_item_error.comparison_error_message = f"File scanning error: {e}"
                comparison_results_dict[REPORT_COMPARE_ERROR].append(comp_item_error)
    
    print("Finished scanning folders\n")

    return scanned_non_excluded_items

# Main comparison function
